'use strict';

var app = angular.module('HibiApp',
  [ 'angular.markdown'
  , 'ui.sortable'
  , 'app.directives'
  ]);


app.controller('PlansCtrl', function ($scope, $http, $log) {
  $scope.plans = #{toJSON activePlans};

  $scope.addNewPlan = function () {
    var plan = {id: '_new', plan: this.newPlan};
    this.newPlan = {};
    this.plans.splice(0, 0, plan);
    $http.post("/plans", plan.plan)
      .success(function (data, status, headers, config) {
        plan.id = data.id;
      }).error(function (data, status, headers, config) {
        plan.broken = true;
      });
  };

  $scope.removePlan = function (plan) {
    var index = this.plans.indexOf(plan);
    if (index > -1) {
      this.plans.splice(index, 1);
    }
  };

  $scope.completePlan = function (plan) {
    plan.going = true;
    var self = this;

    $http.post("/plans/" + plan.id + "/complete")
      .success(function (data, status, headers, config) {
        self.removePlan(plan);
      });
  };

  $scope.deletePlan = function (plan) {
    plan.going = true;
    var self = this;
    $http.delete("/plans/" + plan.id)
      .success(function (data, status, headers, config) {
        self.removePlan(plan);
      });
  };

  $scope.updatePlan = function (plan) {
    return $http.put("/plans/" + plan.id, plan.plan)
      .error(function (data, status, headers, config) {
        $log.warn("Failed to update plan:", arguments);
      });
  };
});


function Task(taskData) {
  if (undefined === taskData) {
    taskData = {};
  }

  this.id = taskData.id || '_new';
  this.task = taskData.task || {
    schedule: #{toJSON Once}
  };
  this.ext_task = taskData.ext_task;
  this.notes = taskData.notes || [];
  this.estimates = taskData.estimates || [];
}

mergeInto(Task.prototype, (function () {
  function endOfDay(date) {
    date.setHours(23);
    date.setMinutes(59);
    date.setSeconds(59);
    return date;
  }

  return {
    isScheduledForToday: function isScheduledForToday() {
      var today = endOfDay(new Date());
      var scheduledFor = new Date(this.task.scheduled_for);
      return scheduledFor <= today;
    },

    isTodoToday: function isTodoToday() {
      return this.task.active && !this.task.done_at && this.isScheduledForToday();
    },

    isOverdue: function isOverdue() {
      var yesterday = endOfDay(new Date());
      // surprisingly, this does the right thing for day 1 (rolls back month)
      yesterday.setDate(yesterday.getDate() - 1);
      var scheduledFor = new Date(this.task.scheduled_for);
      return this.task.active && !this.task.done_at && scheduledFor <= yesterday;
    },
    isPostponed: function isPostponed() {
      return this.task.active && !this.task.done_at && !this.isScheduledForToday();
    },
    isPaused: function isPaused() {
      return !this.task.active && !this.task.done_at;
    },
    isDone: function isDone() {
      return !!this.task.done_at;
    },

    newEstimate: function (pomos) {
      return {estimate: {pomos: pomos, task_id: this.id}};
    },

    addEstimate: function (estimate) {
      var length = this.estimates.push(estimate);
      return length - 1;
    },
    removeEstimate: function (index) {
      return this.estimates.splice(index, 1);
    },

    estimatedPomos: function () {
      if (this.estimates.length == 0) return 0;
      var estimate = this.estimates[0];
      return estimate.estimate.pomos;
    },
    estimatedRemaining: function () {
      return Math.max(0,
        this.estimatedPomos() - this.task.pomos);
    }
  };
}()));


app.factory('Tasks', function ($q, $http) {
  function newTask(taskData) {
    return new Task(taskData);
  }

  var tasksFromServer = #{toJSON tasksWithChildren}.map(newTask);

  function extractData(response) {
    return response.data;
  }

  function taskAction(action) {
    return function (taskId) {
      return $http.post("/tasks/" + taskId + "/" + action)
        .then(extractData)
        .then(newTask);
    };
  }

  var Tasks = {};

  Tasks.all = function () {
    return tasksFromServer;
  };

  Tasks.create = function (task) {
    return $http.post("/tasks", task)
      .then(extractData)
      .then(newTask);
  };

  Tasks.delete = function (taskId) {
    return $http.delete("/tasks/" + taskId)
      .then(extractData);
  };

  Tasks.complete = function (taskId) {
    return $http.post("/tasks/" + taskId + "/complete")
      .then(extractData)
      .then(function (data) {
        var tasks = {};
        if (data.completed) {
          tasks.completed = new Task(data.completed);
        }
        if (data.recurred) {
          tasks.recurred = new Task(data.recurred);
        }
        return tasks;
      });
  };

  Tasks.update = function (task) {
    return $http.put("/tasks/" + task.id, task.task)
      .then(extractData)
      .then(newTask);
  };

  Tasks.edit = function (task, editType, editOptions) {
    var edit = mergeInto({editType: editType}, editOptions);
    return $http({method: 'PATCH', url: '/tasks/' + task.id,
      data: edit
    })
      .then(extractData)
      .then(newTask)
      .then(function (editedTask) {
        task.task = editedTask.task;
        return editedTask;
      });
  };

  Tasks.reorder = function (task, delta) {
    return Tasks.edit(task, 'order', {delta: delta});
  };

  Tasks.logPomos = function (task, pomos) {
    task.task.pomos += pomos;
    return Tasks.edit(task, 'pomos', {pomos: pomos})
      .then(undefined, function (reason) {
        task.task.pomos -= pomos;
        return $q.reject(reason);
      });
  };

  Tasks.addEstimate = function (task, pomos) {
    var estimate = task.newEstimate(pomos);
    var index = task.addEstimate(estimate);
    return $http.post("/tasks/" + task.id + "/estimates", estimate.estimate)
      .then(extractData, function (reason) {
        task.removeEstimate(index);
        return $q.reject(reason);
      });
  };

  [
    'restart',
    'postpone', 'unpostpone',
    'pause', 'unpause'
  ].forEach(function (action) {
    Tasks[action] = taskAction(action);
  });

  return Tasks;
});


app.controller('TasksCtrl', function ($scope, Tasks, $timeout) {
  function makeNewTask() {
    return {
      schedule: #{toJSON Once}
    };
  }

  $scope.tasks = Tasks.all();
  $scope.tasks.todoToday = function todoToday() {
    return this.filter(function (task) {
      return task.isTodoToday();
    });
  };
  $scope.tasks.postponed = function postponed() {
    return this.filter(function (task) {
      return task.isPostponed();
    });
  };
  $scope.tasks.paused = function paused() {
    return this.filter(function (task) {
      return task.isPaused();
    });
  };
  $scope.tasks.done = function done() {
    return this.filter(function (task) {
      return task.isDone();
    });
  };
  $scope.tasks.sort(function (task1, task2) {
    var order1 = task1.task.order, order2 = task2.task.order;
    if (order1 < order2) return -1;
    if (order1 > order2) return 1;
    return 0;
  });
  $scope.newTask = new Task();

  $scope.estimatedRemaining = function estimatedRemaining() {
    var sum = 0;
    $scope.tasks.todoToday().forEach(function (task) {
      sum += task.estimatedRemaining();
    });
    return sum;
  };
  $scope.estimatedTotal = function estimatedTotal() {
    var sum = 0;
    $scope.tasks.todoToday().forEach(function (task) {
      sum += task.estimatedPomos();
    });
    return sum;
  };

  $scope.sortableOptions = {
    handle: '.reorder-handle',
    start: function (event, ui) {
      var start_pos = ui.item.index();
      ui.item.data('start_pos', start_pos);
    },
    update: function (event, ui) {
      var start_pos = ui.item.data('start_pos'),
          end_pos = ui.item.index(),
          delta = end_pos - start_pos;
      var task = $scope.tasks[start_pos];
      $scope.reorderTask(task, delta);
    }
  };

  $scope.postponedOrder = function (task) {
    return new Date(task.task.scheduled_for);
  };
  $scope.pausedOrder = $scope.postponedOrder;
  $scope.doneOrder = function (task) {
    return new Date(task.task.done_at);
  };

  $scope.addNewTask = function () {
    var task = this.newTask;
    this.newTask = new Task();
    this.tasks.splice(this.tasks.length, 0, task);
    Tasks.create(task.task)
      .then(function (created) {
        task.id = created.id;
        task.task = created.task;
        task.notes = created.notes;
      }, function () {
        task.broken = true;
      });
  };

  $scope.removeTask = function (task) {
    var index = this.tasks.indexOf(task);
    if (index > -1) {
      this.tasks.splice(index, 1);
    }
  };

  $scope.completeTask = function (task) {
    task.going = true;
    var self = this;

    Tasks.complete(task.id)
      .then(function (data) {
        if (data.completed) {
          task.going = false;
          task.task = data.completed.task;
        } else {
          task.going = false;
          task.broken = true;
        }

        if (data.recurred) {
          data.recurred.notes = [];
          self.tasks.push(data.recurred);
        }
      }, function () {
        task.going = false;
        task.broken = true;
      });
  };

  $scope.restartTask = function (task) {
    task.going = true;

    Tasks.restart(task.id)
      .then(function (restarted) {
        task.going = false;
        task.task = restarted.task;
      }, function () {
        task.going = false;
        task.broken = true;
      });
  };

  $scope.postponeTask = function (task) {
    task.going = true;

    Tasks.postpone(task.id)
      .then(function (postponed) {
        task.going = false;
        task.task = postponed.task;
      }, function () {
        task.going = false;
        task.broken = true;
      });
  };

  $scope.unpostponeTask = function (task) {
    task.going = true;

    Tasks.unpostpone(task.id)
      .then(function (unpostponed) {
        task.going = false;
        task.task = unpostponed.task;
      }, function () {
        task.going = false;
        task.broken = true;
      });
  };

  $scope.pauseTask = function (task) {
    task.going = true;

    Tasks.pause(task.id)
      .then(function (paused) {
        task.going = false;
        task.task = paused.task;
      }, function () {
        task.going = false;
        task.broken = true;
      });
  };

  $scope.unpauseTask = function (task) {
    task.going = true;

    Tasks.unpause(task.id)
      .then(function (unpaused) {
        task.going = false;
        task.task = unpaused.task;
      }, function () {
        task.going = false;
        task.broken = true;
      });
  };

  $scope.updateTask = function (task) {
    Tasks.update(task)
      // TODO don't noop, apply updated task
      .then(undefined, function () {
        task.broken = true;
      });
  };

  $scope.reorderTask = function (task, delta) {
    Tasks.reorder(task, delta)
      // TODO don't noop, apply updated task
      .then(undefined, function () {
        task.broken = true;
      });
  };

  $scope.deleteTask = function (task) {
    task.going = true;
    var self = this;

    Tasks.delete(task.id)
      .then(function () {
        self.removeTask(task);
      }, function () {
        task.going = false;
        task.broken = true;
      });
  };

  $scope.addEstimate = function (task, pomos) {
    Tasks.addEstimate(task, pomos)
      .then(undefined, function () {
        task.broken = true;
      });
  };

  $scope.logPomo = function (task) {
    Tasks.logPomos(task, 1)
      .then(undefined, function () {
        task.broken = true;
      });
  };


  $scope.showNotes = function (task) {
    task.notes.isVisible = true;
  };

  $scope.hideNotes = function (task) {
    $timeout(function () {
      task.notes.isVisible = false;
    }, 0);
  };
});


app.controller('DoneTasksCtrl', function ($scope) {
  var tasksByDay = {};

  function dateYMD(date) {
    return date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate();
  }

  $scope.dayDone = function (task) {
    if (!task.task.done_at) return null;
    return dateYMD(new Date(task.task.done_at))
  };
  $scope.doneSameDay = function (otherTask) {
    var otherDay = $scope.dayDone(otherTask);
    return function (task) {
      return $scope.dayDone(task) === otherDay;
    };
  };

  $scope.dayOrder = function (task) {
    return $scope.dayDone(task);
  };

  $scope.tasksToFilter = function () {
    // reset day index each time list is rendered
    tasksByDay = {};
    return $scope.tasks;
  };

  $scope.uniqueDay = function (task) {
    var day = $scope.dayDone(task);
    if (!day) return false;
    if (!tasksByDay.hasOwnProperty(day)) {
      tasksByDay[day] = task;
      return true;
    } else {
      return false;
    }
  };
});


/*
 * Based on Angular's builtin 'filter', but for filtering on object properties.
 * Accepts a property name as a string, and returns objects in the array who
 * have a truthy value for that property.  Works for object methods, static
 * properties, or dynamic getters (__defineGetter__).
 *
 * e.g. <div ng-repeat="obj in objs | filterP:'isAwesome'">
 *      would show all objs for which either obj.isAwesome is truthy, or
 *      obj.isAwesome() returns truthy.
 */
app.filter('filterP', function () {
  return function(array, propName) {
    if (!isArray(array)) return array;

    var filtered = [];
    for ( var j = 0; j < array.length; j++) {
      var value = array[j];
      var property = value[propName];
      var propValue;
      if (typeof(property) === 'function') {
        propValue = property.call(value);
      } else {
        propValue = property;
      }
      if (propValue) {
        filtered.push(value);
      }
    }
    return filtered;
  };
});


/*
 * Filter for repeating a set number of times.  e.g.
 *     <div ng-repeat="bottle in 99 | dummyList track by $index">
 *       {{99 - $index}} bottles of beer on the wall...
 */
app.filter('dummyList', function () {
  return function (n) {
    return new Array(n);
  };
});



app.filter('scheduleLabel', function () {
  var labels = {
    #{toJSON Once}: '',
    #{toJSON Daily}: '♳',
    #{toJSON Weekly}: '♹',
    #{toJSON Fortnightly}: '♹♹'
  };
  return function (schedule) {
    return labels[schedule];
  };
});


app.controller('NotesCtrl', function ($scope, $http) {
  $scope.notes = $scope.task.notes;
  $scope.newNote = {};

  $scope.addNewNote = function () {
    var note = {id: '_new', note: this.newNote};
    this.newNote = {};
    this.notes.splice(this.notes.length, 0, note);
    $http.post("/tasks/" + this.task.id + '/notes', note.note)
      .success(function (data, status, headers, config) {
        note.id = data.id;
        note.note = data.note;
      }).error(function (data, status, headers, config) {
        note.broken = true;
      });
  };
});
