function noop() {}

function setupTaskHandlers(taskId) {
  var edit = false;

  var container = $('#' + taskId + ' .title').not('.ext-link');
  var title = container.find('.title');
  var form = container.find('form');
  var textBox = form.find('input[type=text]');

  function leaveEdit() {
    console.debug(taskId + ' leaveEdit');
    title.removeClass('hidden');
    form.addClass('hidden');
    edit = false;
  }
  function localSave() {
    console.debug(taskId + ' localSave');
    title.html(textBox.val());
    leaveEdit();
  }

  form.ajaxForm({
    success: localSave
  });

  textBox
    .blur(function () { if (edit) form.submit(); })
    .keyup(function (e) {
      console.debug(taskId + ' keyUp(' + e.keyCode + ')');
      switch (e.keyCode) {
      case 27: leaveEdit(); break;
      default: /* noop */
      }
    });

  container.click(function () {
    if (edit) return false;
    edit = true;

    console.debug(taskId + ' clicked');
    textBox.val(title.text());
    title.addClass('hidden');
    form.removeClass('hidden');
    textBox.focus();
  });


  var handle = $('#' + taskId + ' .reorder-handle');
  handle.find('form').ajaxForm();
}


function setupNotesHandlers(widgetId) {
  var container = $('#' + widgetId),
      handle = container.find('.notes-handle'),
      counter = handle.find('.counter'),
      notes = container.find('ol.notes'),
      template = container.find('.note-template'),
      form = container.find('form'),
      noteField = form.find('textarea');

  function localSave(data) {
    var noteLi = $('<li class="note">').html(renderNote(data.note));
    notes.append(noteLi);
    form.clearForm();

    var numNotes = notes.find('li').length;
    counter.removeClass('hidden').html(numNotes);
    handle.removeClass('empty');

    noteField.focus();
  }

  function renderNote(note) {
    function paras(str) {
      return "<p>" + str.replace(/\n\n/g, "<\p><p>") + "<\p>";
    }
    return template.clone().removeClass('hidden')
      .find('.body').html(paras(note.body)).end();
  }

  form.ajaxForm({
    success: localSave
  });
}


$(function () {
  $('section#todo table tbody').sortable({
    distance: 15,
    handle: '.reorder-handle',
    start: function (event, ui) {
      var start_pos = ui.item.index();
      ui.item.data('start_pos', start_pos);
    },
    update: function (event, ui) {
      var start_pos = ui.item.data('start_pos'),
          end_pos = ui.item.index(),
          delta = end_pos - start_pos,
          form = ui.item.find('.reorder-handle form'),
          delta_input = form.find('input[type=number]');
      delta_input.val(delta);
      form.submit();
    }
  });

  //$('tr.task').each(function (_, elem) {
  //  setupTaskHandlers(elem.id);

  //  var notesElem = $(elem).find('td.notes > div');
  //  switch (notesElem.length) {
  //  case 0: break;
  //  case 1:
  //    setupNotesHandlers(notesElem[0].id);
  //    break;
  //  default:
  //    console.warn("Found " + notesElem.length + " notes divs for " + elem.id);
  //  }
  //});
});


var app = angular.module('HibiApp', ['angular.markdown', 'ui.sortable']);


app.controller('PlansCtrl', function ($scope, $http, $log) {
  $scope.plans = #{toJSON activePlans};

  $scope.addNewPlan = function () {
    var plan = {id: '_new', plan: this.newPlan};
    this.newPlan = {};
    this.plans.splice(0, 0, plan);
    $http.post("/plans", plan.plan)
      .success(function (data, status, headers, config) {
        plan.id = data.id;
      }).error(function (data, status, headers, config) {
        plan.broken = true;
      });
  };

  $scope.removePlan = function (plan) {
    var index = this.plans.indexOf(plan);
    if (index > -1) {
      this.plans.splice(index, 1);
    }
  };

  $scope.completePlan = function (plan) {
    plan.going = true;
    var self = this;

    $http.post("/plans/" + plan.id + "/complete")
      .success(function (data, status, headers, config) {
        self.removePlan(plan);
      });
  };

  $scope.deletePlan = function (plan) {
    plan.going = true;
    var self = this;
    $http.delete("/plans/" + plan.id)
      .success(function (data, status, headers, config) {
        self.removePlan(plan);
      });
  };

  $scope.updatePlan = function (plan) {
    return $http.put("/plans/" + plan.id, plan.plan)
      .error(function (data, status, headers, config) {
        $log.warn("Failed to update plan:", arguments);
      });
  };
});


function Task(taskData) {
  if (undefined === taskData) {
    taskData = {};
  }

  this.id = taskData.id || '_new';
  this.task = taskData.task || {
    schedule: #{toJSON Once}
  };
  this.ext_task = taskData.ext_task;
  this.notes = taskData.notes || [];
  this.estimates = taskData.estimates || [];
}


app.factory('Tasks', function ($q, $http) {
  function newTask(taskData) {
    return new Task(taskData);
  }

  var tasksFromServer = #{toJSON tasksWithChildren}.map(newTask);

  function extractData(response) {
    return response.data;
  }

  function taskAction(action) {
    return function (taskId) {
      return $http.post("/tasks/" + taskId + "/" + action)
        .then(extractData)
        .then(newTask);
    };
  }

  var Tasks = {};

  Tasks.all = function () {
    return tasksFromServer;
  };

  Tasks.create = function (task) {
    return $http.post("/tasks", task)
      .then(extractData)
      .then(newTask);
  };

  Tasks.delete = function (taskId) {
    return $http.delete("/tasks/" + taskId)
      .then(extractData);
  };

  Tasks.complete = function (taskId) {
    return $http.post("/tasks/" + taskId + "/complete")
      .then(extractData)
      .then(function (data) {
        var tasks = {};
        if (data.completed) {
          tasks.completed = new Task(data.completed);
        }
        if (data.recurred) {
          tasks.recurred = new Task(data.recurred);
        }
        return tasks;
      });
  };

  Tasks.update = function (task) {
    return $http.put("/tasks/" + task.id, task.task)
      .then(extractData)
      .then(newTask);
  };

  Tasks.edit = function (task, editType, editOptions) {
    var edit = {editType: editType};
    for (var k in editOptions) {
      if (editOptions.hasOwnProperty(k))
        edit[k] = editOptions[k];
    }
    return $http({method: 'PATCH', url: '/tasks/' + task.id,
      data: edit
    })
      .then(extractData)
      .then(newTask)
      .then(function (editedTask) {
        task.task = editedTask.task;
        return editedTask;
      });
  };

  Tasks.reorder = function (task, delta) {
    return Tasks.edit(task, 'order', {delta: delta});
  };

  [
    'restart',
    'postpone', 'unpostpone',
    'pause', 'unpause'
  ].forEach(function (action) {
    Tasks[action] = taskAction(action);
  });

  return Tasks;
});


app.controller('TasksCtrl', function ($scope, Tasks, $timeout) {
  function makeNewTask() {
    return {
      schedule: #{toJSON Once}
    };
  }

  $scope.tasks = Tasks.all();
  $scope.tasks.sort(function (task1, task2) {
    var order1 = task1.task.order, order2 = task2.task.order;
    if (order1 < order2) return -1;
    if (order1 > order2) return 1;
    return 0;
  });
  $scope.newTask = new Task();

  $scope.sortableOptions = {
    handle: '.reorder-handle',
    start: function (event, ui) {
      var start_pos = ui.item.index();
      ui.item.data('start_pos', start_pos);
    },
    update: function (event, ui) {
      var start_pos = ui.item.data('start_pos'),
          end_pos = ui.item.index(),
          delta = end_pos - start_pos;
      var task = $scope.tasks[start_pos];
      $scope.reorderTask(task, delta);
    }
  };

  function endOfDay(date) {
    date.setHours(23);
    date.setMinutes(59);
    date.setSeconds(59);
    return date;
  }

  function isScheduledForToday(task) {
    var today = endOfDay(new Date());
    var scheduledFor = new Date(task.task.scheduled_for);
    return scheduledFor <= today;
  }

  $scope.isTodoToday = function (task) {
    return task.task.active && !task.task.done_at && isScheduledForToday(task);
  };
  $scope.isOverdue = function (task) {
    var yesterday = endOfDay(new Date());
    // surprisingly, this does the right thing for day 1 (rolls back month)
    yesterday.setDate(yesterday.getDate() - 1);
    var scheduledFor = new Date(task.task.scheduled_for);
    return task.task.active && !task.task.done_at && scheduledFor <= yesterday;
  };
  $scope.isPostponed = function (task) {
    return task.task.active && !task.task.done_at && !isScheduledForToday(task);
  };
  $scope.isPaused = function (task) {
    return !task.task.active && !task.task.done_at;
  };
  $scope.isDone = function (task) {
    return !!task.task.done_at;
  };

  $scope.postponedOrder = function (task) {
    return new Date(task.task.scheduled_for);
  };
  $scope.pausedOrder = $scope.postponedOrder;
  $scope.doneOrder = function (task) {
    return new Date(task.task.done_at);
  };

  $scope.addNewTask = function () {
    var task = this.newTask;
    this.newTask = new Task();
    this.tasks.splice(this.tasks.length, 0, task);
    Tasks.create(task.task)
      .then(function (created) {
        task.id = created.id;
        task.task = created.task;
        task.notes = created.notes;
      }, function () {
        task.broken = true;
      });
  };

  $scope.removeTask = function (task) {
    var index = this.tasks.indexOf(task);
    if (index > -1) {
      this.tasks.splice(index, 1);
    }
  };

  $scope.completeTask = function (task) {
    task.going = true;
    var self = this;

    Tasks.complete(task.id)
      .then(function (data) {
        if (data.completed) {
          task.going = false;
          task.task = data.completed.task;
        } else {
          task.going = false;
          task.broken = true;
        }

        if (data.recurred) {
          data.recurred.notes = [];
          self.tasks.push(data.recurred);
        }
      }, function () {
        task.going = false;
        task.broken = true;
      });
  };

  $scope.restartTask = function (task) {
    task.going = true;

    Tasks.restart(task.id)
      .then(function (restarted) {
        task.going = false;
        task.task = restarted.task;
      }, function () {
        task.going = false;
        task.broken = true;
      });
  };

  $scope.postponeTask = function (task) {
    task.going = true;

    Tasks.postpone(task.id)
      .then(function (postponed) {
        task.going = false;
        task.task = postponed.task;
      }, function () {
        task.going = false;
        task.broken = true;
      });
  };

  $scope.unpostponeTask = function (task) {
    task.going = true;

    Tasks.unpostpone(task.id)
      .then(function (unpostponed) {
        task.going = false;
        task.task = unpostponed.task;
      }, function () {
        task.going = false;
        task.broken = true;
      });
  };

  $scope.pauseTask = function (task) {
    task.going = true;

    Tasks.pause(task.id)
      .then(function (paused) {
        task.going = false;
        task.task = paused.task;
      }, function () {
        task.going = false;
        task.broken = true;
      });
  };

  $scope.unpauseTask = function (task) {
    task.going = true;

    Tasks.unpause(task.id)
      .then(function (unpaused) {
        task.going = false;
        task.task = unpaused.task;
      }, function () {
        task.going = false;
        task.broken = true;
      });
  };

  $scope.updateTask = function (task) {
    Tasks.update(task)
      // TODO don't noop, apply updated task
      .then(noop, function () {
        task.broken = true;
      });
  };

  $scope.reorderTask = function (task, delta) {
    Tasks.reorder(task, delta)
      // TODO don't noop, apply updated task
      .then(noop, function () {
        task.broken = true;
      });
  };

  $scope.deleteTask = function (task) {
    task.going = true;
    var self = this;

    Tasks.delete(task.id)
      .then(function () {
        self.removeTask(task);
      }, function () {
        task.going = false;
        task.broken = true;
      });
  };


  $scope.showNotes = function (task) {
    task.notes.isVisible = true;
  };

  $scope.hideNotes = function (task) {
    $timeout(function () {
      task.notes.isVisible = false;
    }, 0);
  };
});


app.controller('DoneTasksCtrl', function ($scope) {
  var tasksByDay = {};

  function dateYMD(date) {
    return date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate();
  }

  $scope.dayDone = function (task) {
    if (!task.task.done_at) return null;
    return dateYMD(new Date(task.task.done_at))
  };
  $scope.doneSameDay = function (otherTask) {
    var otherDay = $scope.dayDone(otherTask);
    return function (task) {
      return $scope.dayDone(task) === otherDay;
    };
  };

  $scope.dayOrder = function (task) {
    return $scope.dayDone(task);
  };

  $scope.tasksToFilter = function () {
    // reset day index each time list is rendered
    tasksByDay = {};
    return $scope.tasks;
  };

  $scope.uniqueDay = function (task) {
    var day = $scope.dayDone(task);
    if (!day) return false;
    if (!tasksByDay.hasOwnProperty(day)) {
      tasksByDay[day] = task;
      return true;
    } else {
      return false;
    }
  };
});


app.filter('scheduleLabel', function () {
  var labels = {
    #{toJSON Once}: '',
    #{toJSON Daily}: '♳',
    #{toJSON Weekly}: '♹',
    #{toJSON Fortnightly}: '♹♹'
  };
  return function (schedule) {
    return labels[schedule];
  };
});


app.controller('NotesCtrl', function ($scope, $http) {
  $scope.notes = $scope.task.notes;
  $scope.newNote = {};

  $scope.addNewNote = function () {
    var note = {id: '_new', note: this.newNote};
    this.newNote = {};
    this.notes.splice(this.notes.length, 0, note);
    $http.post("/tasks/" + this.task.id + '/notes', note.note)
      .success(function (data, status, headers, config) {
        note.id = data.id;
        note.note = data.note;
      }).error(function (data, status, headers, config) {
        note.broken = true;
      });
  };
});


app.directive('ngBlur', function ($parse) {
  return function (scope, element, attrs) {
    var fn = $parse(attrs['ngBlur']);
    element.bind('blur', function (event) {
      scope.$apply(function () {
        fn(scope, {$event: event});
      });
    });
  };
});


app.directive('ssEscape', function ($parse) {
  return function (scope, element, attrs) {
    var fn = $parse(attrs['ssEscape']);
    element.bind('keydown', function (event) {
      if (event.keyCode == 27) {
        scope.$apply(function () {
          fn(scope, {$event: event});
        });
      }
    });
  };
});


app.directive('ssCtrlEnter', function ($parse) {
  return function (scope, element, attrs) {
    var fn = $parse(attrs['ssCtrlEnter']);
    element.bind('keydown', function (event) {
      if ((event.keyCode == 10 || event.keyCode == 13) && event.ctrlKey) {
        scope.$apply(function () {
          fn(scope, {$event: event});
        });
      }
    });
  };
});


app.directive('ssEditablePopup', function () {
  return {
    restrict: 'EA',

    scope: {
      show: '&ssShow'
    },

    transclude: true,
    replace: true,

    template: ' \
      <div ng-show="show() || inputsFocused &gt; 0" ng-transclude /> \
    ',

    link: function (scope, element, attrs) {
      var inputs = element.find('input, textarea');

      scope.inputsFocused = 0;

      inputs.bind('focus', function (event) {
        scope.$apply(function () { scope.inputsFocused += 1; });
      }).bind('blur', function (event) {
        scope.$apply(function () { scope.inputsFocused -= 1; });
      }).bind('keydown', function (event) {
        if (event.keyCode == 27) {
          this.blur();
        }
      });
    }
  };
});


app.directive('ssClickToEdit', function ($timeout) {
  return {
    restrict: 'E',

    scope: {
      value: '=ssModel',
      onEdit: '&ssOnEdit'
    },

    transclude: true,


    template: ' \
      <div ng-hide="editing" ng-click="switchToEdit()" ng-transclude /> \
      <form ng-submit="save()"> \
        <input class="editor" \
            ng-model="value" \
            ng-show="editing" \
            ng-blur="editorBlur()" \
            ss-escape="leaveEdit(true)" \
        /> \
    ',


    link: function (scope, element, attrs) {

      scope.editing = false;

      scope.switchToEdit = function () {
        var editor = element.find('input.editor');
        $timeout(function () { editor.focus(); });
        this.original = this.value;
        this.editing = true;
      };

      scope.leaveEdit = function (discard) {
        this.editing = false;

        if (discard) {
          this.value = this.original;
        }
      };

      scope.save = function () {
        var onEdit = this.onEdit();
        if ("undefined" === typeof(onEdit)) {
          return this.leaveEdit(false);
        }
        onEdit.then(
          angular.bind(this, this.leaveEdit, false),
          angular.bind(this, this.leaveEdit, true));
      };

      scope.editorBlur = function () {
        if (this.editing) {
          this.save();
        }
      };

    }
  };
});
