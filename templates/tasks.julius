'use strict';

var app = angular.module('HibiApp',
  [ 'angular.markdown'
  , 'ui.sortable'
  , 'app.services'
  , 'app.controllers'
  , 'app.directives'
  , 'app.filters'
  ])
.value('initialPlanData', #{toJSON activePlans});


function Task(taskData) {
  if (undefined === taskData) {
    taskData = {};
  }

  this.id = taskData.id || '_new';
  this.task = taskData.task || {
    schedule: #{toJSON Once}
  };
  this.ext_task = taskData.ext_task;
  this.notes = taskData.notes || [];
  this.estimates = taskData.estimates || [];
}

mergeInto(Task.prototype, (function () {
  function endOfDay(date) {
    date.setHours(23);
    date.setMinutes(59);
    date.setSeconds(59);
    return date;
  }

  return {
    isScheduledForToday: function isScheduledForToday() {
      var today = endOfDay(new Date());
      var scheduledFor = new Date(this.task.scheduled_for);
      return scheduledFor <= today;
    },

    isTodoToday: function isTodoToday() {
      return this.task.active && !this.task.done_at && this.isScheduledForToday();
    },

    isOverdue: function isOverdue() {
      var yesterday = endOfDay(new Date());
      // surprisingly, this does the right thing for day 1 (rolls back month)
      yesterday.setDate(yesterday.getDate() - 1);
      var scheduledFor = new Date(this.task.scheduled_for);
      return this.task.active && !this.task.done_at && scheduledFor <= yesterday;
    },
    isPostponed: function isPostponed() {
      return this.task.active && !this.task.done_at && !this.isScheduledForToday();
    },
    isPaused: function isPaused() {
      return !this.task.active && !this.task.done_at;
    },
    isDone: function isDone() {
      return !!this.task.done_at;
    },

    newEstimate: function (pomos) {
      return {estimate: {pomos: pomos, task_id: this.id}};
    },

    addEstimate: function (estimate) {
      var length = this.estimates.push(estimate);
      return length - 1;
    },
    removeEstimate: function (index) {
      return this.estimates.splice(index, 1);
    },

    estimatedPomos: function () {
      if (this.estimates.length == 0) return 0;
      var estimate = this.estimates[0];
      return estimate.estimate.pomos;
    },
    estimatedRemaining: function () {
      return Math.max(0,
        this.estimatedPomos() - this.task.pomos);
    }
  };
}()));


app.factory('Tasks', function ($q, $http) {
  function newTask(taskData) {
    return new Task(taskData);
  }

  var tasksFromServer = #{toJSON tasksWithChildren}.map(newTask);

  function extractData(response) {
    return response.data;
  }

  function taskAction(action) {
    return function (taskId) {
      return $http.post("/tasks/" + taskId + "/" + action)
        .then(extractData)
        .then(newTask);
    };
  }

  var Tasks = {};

  Tasks.all = function () {
    return tasksFromServer;
  };

  Tasks.create = function (task) {
    return $http.post("/tasks", task)
      .then(extractData)
      .then(newTask);
  };

  Tasks.delete = function (taskId) {
    return $http.delete("/tasks/" + taskId)
      .then(extractData);
  };

  Tasks.complete = function (taskId) {
    return $http.post("/tasks/" + taskId + "/complete")
      .then(extractData)
      .then(function (data) {
        var tasks = {};
        if (data.completed) {
          tasks.completed = new Task(data.completed);
        }
        if (data.recurred) {
          tasks.recurred = new Task(data.recurred);
        }
        return tasks;
      });
  };

  Tasks.update = function (task) {
    return $http.put("/tasks/" + task.id, task.task)
      .then(extractData)
      .then(newTask);
  };

  Tasks.edit = function (task, editType, editOptions) {
    var edit = mergeInto({editType: editType}, editOptions);
    return $http({method: 'PATCH', url: '/tasks/' + task.id,
      data: edit
    })
      .then(extractData)
      .then(newTask)
      .then(function (editedTask) {
        task.task = editedTask.task;
        return editedTask;
      });
  };

  Tasks.reorder = function (task, delta) {
    return Tasks.edit(task, 'order', {delta: delta});
  };

  Tasks.logPomos = function (task, pomos) {
    task.task.pomos += pomos;
    return Tasks.edit(task, 'pomos', {pomos: pomos})
      .then(undefined, function (reason) {
        task.task.pomos -= pomos;
        return $q.reject(reason);
      });
  };

  Tasks.addEstimate = function (task, pomos) {
    var estimate = task.newEstimate(pomos);
    var index = task.addEstimate(estimate);
    return $http.post("/tasks/" + task.id + "/estimates", estimate.estimate)
      .then(extractData, function (reason) {
        task.removeEstimate(index);
        return $q.reject(reason);
      });
  };

  [
    'restart',
    'postpone', 'unpostpone',
    'pause', 'unpause'
  ].forEach(function (action) {
    Tasks[action] = taskAction(action);
  });

  return Tasks;
});


app.filter('scheduleLabel', function () {
  var labels = {
    #{toJSON Once}: '',
    #{toJSON Daily}: '♳',
    #{toJSON Weekly}: '♹',
    #{toJSON Fortnightly}: '♹♹'
  };
  return function (schedule) {
    return labels[schedule];
  };
});
